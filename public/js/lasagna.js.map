{"version":3,"sources":["webpack:///webpack/bootstrap e10b89e08a5207979fb4","webpack:///./src/elements/LasagnaActivityLogElement.ts","webpack:///./~/diffhtml/dist/diffhtml.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/app.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AC9DA,wCAAqC;AAErC,IAAM,OAAO,GAAG,OAAO,CAAC;AACxB,IAAM,mBAAmB,GAAG;IAC1B,KAAK,EAAE,MAAM;IACb,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,SAAS;CAChB,CAAC;AAEF;IAAiC,sCAAW;IAC1C;eACE,iBAAO;IACT,CAAC;IAED,sBAAI,wCAAQ;aAAZ;YACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAAC,MAAM,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;YACtF,IAAM,YAAY,GAAQ,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;YACpE,MAAM,CAAC;gBACL,IAAI,EAAE,YAAY,CAAC,IAAI,IAAI,EAAE;gBAC7B,OAAO,EAAE,YAAY,CAAC,OAAO,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,IAAI;gBACrE,OAAO,EAAE,YAAY,CAAC,OAAO,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,IAAI;aACtE,CAAC;QACJ,CAAC;;;OAAA;IAED,8CAAiB,GAAjB;QACE,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,SAAS,GAAG,4+BAqCiB,QAAQ,CAAC,IAAI,4IAGb,QAAQ,CAAC,OAAO,kHAGhB,QAAQ,CAAC,OAAO,kJAMjD,CAAC;IACJ,CAAC;IACH,yBAAC;AAAD,CAAC,CApEgC,WAAW,GAoE3C;AACK,MAAO,CAAC,cAAc,CAAC,MAAM,CAAC,+BAA+B,EAAE,kBAAkB,CAAC,CAAC;AAEzF;;GAEG;AACH;IAAuD,6CAAW;IAEhE;;OAEG;IACH;eACE,iBAAO;IACT,CAAC;IAKD,sBAAW,+CAAkB;QAH7B;;WAEG;aACH,cAAkC,MAAM,CAAC,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC;;;OAAA;IAElE;;;;;OAKG;IACH,4DAAwB,GAAxB,UAAyB,IAAY,EAAE,QAAgB,EAAE,QAAgB;QACvE,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACb,KAAK,MAAM;gBACT,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,KAAK,CAAC;YACR;gBACE,KAAK,CAAC;QACV,CAAC;IACH,CAAC;IAKD,sBAAI,2CAAI;QAHR;;WAEG;aACH;YACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;gBAAC,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;YAClD,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;QAC7C,CAAC;aAED,UAAS,KAAW;YAClB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;QACjD,CAAC;;;OAJA;IAMD;;OAEG;IACH,qDAAiB,GAAjB;QACE,IAAM,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC,CAAC;QACrD,UAAU,CAAC,SAAS,GAAG,kxBA6BtB,CAAC;QACF,IAAI,CAAC,MAAM,EAAE,CAAC;IAChB,CAAC;IAED,0CAAM,GAAN;QACE,oBAAS,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,oFAEK,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,mBAAmB,CAAC,gcAS7G,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,yBAE9B,CAAC,CAAC;IACL,CAAC;IAED,oDAAgB,GAAhB,UAAiB,UAA0B;QACzC,IAAM,QAAQ,GAAG,UAAU,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,QAAQ,IAAK,OAAG,GAAG,oEAAiE,EAAvE,CAAuE,EAAE,EAAE,CAAC,CAAC;QACnI,MAAM,CAAI,QAAQ,oEAAiE,CAAC;IACtF,CAAC;IACH,gCAAC;AAAD,CAAC,CArGsD,WAAW,GAqGjE;;;;;;;;0DC1LD,yBAAa,SAA2D,mBAAmB,gDAAgD,aAAa,KAAK,MAAM,gCAAgC,SAAS,qCAAqC,SAAS,mCAAmC,OAAO,KAAK,OAAO,cAAc,aAAa,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AACxyB;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,SAAS,WAAW;AAC/B;AACA;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,SAAS,WAAW;AAC/B;AACA;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS,WAAW;AAC/B;AACA;AACA,wEAAwE;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,mIAAmI;AACtI;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,gEAAgE;AACrJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA,CAAC,EAAE,+DAA+D;AAClE;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB,OAAO;AAC5B,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,0DAA0D;AAC7D;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,sBAAsB,uEAAuE;AAC7F,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA,8BAA8B,uEAAuE;AACrG,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF;AACzF,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,yJAAyJ;AAC5J;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,uCAAuC;AAC1C;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAiD;;AAE1F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,iDAAiD;;AAErF;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,+JAA+J;AAClK;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC,EAAE,wDAAwD;AAC3D;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,CAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;AACA,CAAC;AACD;;AAEA,kCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE;;AAEjM;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,sBAAsB;AAC3D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;;AAEA,+BAA+B,qCAAqC;AACpE;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;;AAEA,+BAA+B,uCAAuC;AACtE;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC,GAAG;AACJ;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,qIAAqI;AACtI,CAAC,GAAG;AACJ;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,0CAA0C;AAC1C,GAAG;AACH;;AAEA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,CAAC,EAAE,gCAAgC;AACnC;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,OAAO,WAAW;AAClB,MAAM,qBAAqB;AAC3B,OAAO,qBAAqB;AAC5B,OAAO;AACP;;AAEA;AACA,OAAO,qBAAqB;AAC5B,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,MAAM,YAAY;AAClB,OAAO,wBAAwB;AAC/B,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,CAAC,EAAE,gEAAgE;AACnE;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,YAAY,MAAM;AAClB;;AAEA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;;AAEA,CAAC,GAAG;AACJ;;AAEA;AACA;AACA,CAAC;;AAED,oGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;;AAEA;;AAEA;;AAEA;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,aAAa;AACzB;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC,EAAE,4BAA4B;AAC/B;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,aAAa;AACjG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC,GAAG,EAAE,GAAG;AACT,CAAC,E;;;;;;;ACnmFD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;AClBA,yDAA6E;AAE7E;;GAEG;AACG,MAAO,CAAC,cAAc,CAAC,MAAM,CAAC,sBAAsB,EAAE,mCAAyB,CAAC,CAAC;AAEvF;;GAEG;AACH,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;IAC9B,IAAM,KAAK,GAAG,IAAI,IAAI,EAAE,CAAC;IACzB,IAAM,UAAU,GAAmB,EAAE,CAAC;IACtC,IAAM,WAAW,GAAG,QAAQ,CAAC,aAAa,CAAC,sBAAsB,CAAC,CAAC;IACnE,WAAW,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACpE,WAAW,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;AACrE,CAAC,CAAC,CAAC","file":"lasagna.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e10b89e08a5207979fb4","import { ActivityData } from '../interfaces/ActivityData';\n\nimport { innerHTML } from 'diffhtml';\n\nconst LOCALES = 'en-US';\nconst DATE_STRING_OPTIONS = {\n  month: 'long',\n  day: 'numeric',\n  year: 'numeric'\n};\n\nclass LogActivityElement extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  get activity(): ActivityData {\n    if (!this.hasAttribute('activity')) return { task: '', started: null, stopped: null };\n    const activityData = <any>JSON.parse(this.getAttribute('activity'));\n    return {\n      task: activityData.task || '',\n      started: activityData.started ? new Date(activityData.started) : null,\n      stopped: activityData.stopped ? new Date(activityData.stopped) : null\n    };\n  }\n\n  connectedCallback() {\n    const activity = this.activity;\n    this.innerHTML = `\n      <style>\n        .c-activity {\n          display: flex;\n          flex-direction: row;\n        }\n        .c-activity > * {\n          display: inline-block;\n          margin: 0.1rem 0.25rem;\n          border-bottom: 1px solid black;\n          padding: 0 0.25rem;\n        }\n        .c-activity > * > input {\n          margin: 0;\n          width: 100%;\n          height: 1.1rem;\n          border: none;\n          padding: 0;\n          font-size: 1rem;\n        }\n        .c-activity__task {\n          width: calc(100% - 26.5rem);\n        }\n        .c-activity__task > input {\n          text-align: left;\n        }\n        .c-activity__time,\n        .c-activity__duration {\n          width: calc(7.5rem);\n        }\n        .c-activity__time > input,\n        .c-activity__duration > input {\n          text-align: center;\n        }\n      </style>\n      <form class=\"c-activity\">\n        <label class=\"c-activity__task\">\n          <input type=\"text\" value=\"${activity.task}\" placeholder=\"Task name\">\n        </label>\n        <label class=\"c-activity__time\">\n          <input type=\"time\" value=\"${activity.started}\">\n        </label>\n        <label class=\"c-activity__time\">\n          <input type=\"time\" value=\"${activity.stopped}\">\n        </label>\n        <label class=\"c-activity__duration\">\n          <input type=\"text\">\n        </label>\n      </form>\n    `;\n  }\n}\n(<any>window).customElements.define('lasagna-activity-log-activity', LogActivityElement);\n\n/**\n * Activity Log web component behavior\n */\nexport default class LasagnaActivityLogElement extends HTMLElement {\n\n  /**\n   * Activity Log element constructor\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Attributes to watch for changes\n   */\n  static get observedAttributes() { return ['date', 'activities']; }\n\n  /**\n   * Handle changes to observed attributes\n   * @param attr Name of the changed attribute\n   * @param oldValue Attribute's old value\n   * @param newValue Attribute's new value\n   */\n  attributeChangedCallback(attr: string, oldValue: string, newValue: string) {\n    switch (attr) {\n      case 'date':\n        this.render();\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Date of activities listed in this log\n   */\n  get date(): Date {\n    if (!this.hasAttribute('date')) return new Date();\n    return new Date(this.getAttribute('date'));\n  }\n\n  set date(value: Date) {\n    this.setAttribute('date', value.toISOString());\n  }\n\n  /**\n   * Complete construction of DOM element\n   */\n  connectedCallback() {\n    const shadowRoot = this.attachShadow({mode: 'open'});\n    shadowRoot.innerHTML = `\n      <style>\n        .c-activity-log__title {\n          font-size: 1.5rem;\n          font-weight: 600;\n        }\n        .c-activity-log__headings {\n          display: flex;\n          flex-direction: row;\n        }\n        .c-activity-log__headings > * {\n          display: inline-block;\n          margin: 0.1rem 0.25rem;\n          border-bottom: 1px solid transparent;\n          padding: 0.25rem;\n          font-weight: 500;\n        }\n        .c-activity-log__task-heading {\n          width: calc(100% - 26.5rem);\n          text-align: left;\n        }\n        .c-activity-log__time-heading,\n        .c-activity-log__duration-heading {\n          width: 7.5rem;\n          text-align: center;\n        }\n      </style>\n      <section>\n      </section>\n    `;\n    this.render();\n  }\n\n  render() {\n    innerHTML(this.shadowRoot.querySelector('section'), `\n      <header>\n        <h1 class=\"c-activity-log__title\">Activity Log for ${this.date.toLocaleDateString(LOCALES, DATE_STRING_OPTIONS)}</h1>\n        <div class=\"c-activity-log__headings\">\n          <span class=\"c-activity-log__task-heading\">Task</span>\n          <span class=\"c-activity-log__time-heading\">Started At</span>\n          <span class=\"c-activity-log__time-heading\">Stopped At</span>\n          <span class=\"c-activity-log__duration-heading\">Duration</span>\n        </div>\n      </header>\n      <div class=\"c-activity-log__activities\">\n        ${this.renderActivities([])}\n      </div>\n    `);\n  }\n\n  renderActivities(activities: ActivityData[]): String {\n    const elements = activities.reduce((acc, activity) => `${acc}<lasagna-activity-log-activity></lasagna-activity-log-activity>`, '');\n    return `${elements}<lasagna-activity-log-activity></lasagna-activity-log-activity>`;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/elements/LasagnaActivityLogElement.ts","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.diff = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAttribute = exports.createElement = exports.release = exports.html = undefined;\n\nvar _taggedTemplate = _dereq_('./util/tagged-template');\n\nObject.defineProperty(exports, 'html', {\n  enumerable: true,\n  get: function get() {\n    return _taggedTemplate.html;\n  }\n});\n\nvar _release = _dereq_('./node/release');\n\nObject.defineProperty(exports, 'release', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_release).default;\n  }\n});\n\nvar _helpers = _dereq_('./tree/helpers');\n\nObject.defineProperty(exports, 'createElement', {\n  enumerable: true,\n  get: function get() {\n    return _helpers.createElement;\n  }\n});\nObject.defineProperty(exports, 'createAttribute', {\n  enumerable: true,\n  get: function get() {\n    return _helpers.createAttribute;\n  }\n});\nexports.outerHTML = outerHTML;\nexports.innerHTML = innerHTML;\nexports.element = element;\nexports.addTransitionState = addTransitionState;\nexports.removeTransitionState = removeTransitionState;\nexports.use = use;\n\nvar _transaction = _dereq_('./node/transaction');\n\nvar _transaction2 = _interopRequireDefault(_transaction);\n\nvar _transitions = _dereq_('./util/transitions');\n\nvar _cache = _dereq_('./util/cache');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Used to diff the outerHTML contents of the passed element with the markup\n * contents. Very useful for applying a global diff on the\n * `document.documentElement`.\n *\n * @example\n *\n *    import { outerHTML } from 'diffhtml'\n *\n *    // Remove all attributes and set the children to be a single text node\n *    // containing the text 'Hello world',\n *    outerHTML(document.body, '<body>Hello world</body>')\n *\n *\n * @param {Object} element - A DOM Node to render into\n * @param {String|Object} markup='' - A string of markup or virtual tree\n * @param {Object =} options={} - An object containing configuration options\n */\nfunction outerHTML(element) {\n  var markup = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  options.inner = false;\n  (0, _transaction2.default)(element, markup, options);\n}\n\n/**\n * Used to diff the innerHTML contents of the passed element with the markup\n * contents. This is useful with libraries like Backbone that render Views\n * into element container.\n *\n * @example\n *\n *    import { innerHTML } from 'diffhtml'\n *\n *    // Sets the body children to be a single text node containing the text\n *    // 'Hello world'.\n *    innerHTML(document.body, 'Hello world')\n *\n *\n * @param {Object} element - A DOM Node to render into\n * @param {String|Object} markup='' - A string of markup or virtual tree\n * @param {Object =} options={} - An object containing configuration options\n */\nfunction innerHTML(element) {\n  var markup = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  options.inner = true;\n  (0, _transaction2.default)(element, markup, options);\n}\n\n/**\n * Used to diff two elements. The `inner` Boolean property can be specified in\n * the options to set innerHTML\\outerHTML behavior. By default it is\n * outerHTML.\n *\n * @example\n *\n *    // It is usually better to rename this method to something descriptive.\n *    import { element as diffElement } from 'diffhtml'\n *\n *    // Create a new body tag.\n *    const newBody = $(`<body>\n *      <strong>Hello world!</strong>\n *    </body>`).get();\n *\n *\n *    diffElement(document.body, newBody);\n *\n *\n * @param {Object} element - A DOM Node to render into\n * @param {Object} newElement - A string of markup or virtual tree\n * @param {Object =} options={} - An object containing configuration options\n */\nfunction element(element, newElement) {\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  (0, _transaction2.default)(element, newElement, options);\n}\n\n/**\n * Adds a global transition listener. With many elements this could be an\n * expensive operation, so try to limit the amount of listeners added if you're\n * concerned about performance.\n *\n * Since the callback triggers with various elements, most of which you\n * probably don't care about, you'll want to filter. A good way of filtering\n * is to use the DOM `matches` method. It's fairly well supported\n * (http://caniuse.com/#feat=matchesselector) and may suit many projects. If\n * you need backwards compatibility, consider using jQuery's `is`.\n *\n * @example\n *\n *    import { addTransitionState } from 'diffhtml'\n *\n *    // Fade in all elements as they are added to the DOM.\n *    addTransitionState('attached', el => $(el).fadeIn().promise())\n *\n *    // Fade out all elements as they leave the DOM.\n *    addTransitionState('detached', el => $(el).fadeOut().promise())\n *\n *\n * @param state - String name that matches what's available in the\n * documentation above.\n * @param callback - Function to receive the matching elements.\n */\nfunction addTransitionState(state, callback) {\n  if (!state) {\n    throw new Error('Missing transition state name');\n  }\n\n  if (!callback) {\n    throw new Error('Missing transition state callback');\n  }\n\n  // Not a valid state name.\n  if (Object.keys(_transitions.states).indexOf(state) === -1) {\n    throw new Error('Invalid state name: ' + state);\n  }\n\n  _transitions.states[state].push(callback);\n}\n\n/**\n * Removes a global transition listener.\n *\n * When invoked with no arguments, this method will remove all transition\n * callbacks. When invoked with the name argument it will remove all transition\n * state callbacks matching the name, and so on for the callback.\n *\n * @example\n *\n *    import { removeTransitionState } from 'diffhtml'\n *\n *    // Remove all transition state handlers.\n *    removeTransitionState()\n *\n *    // Remove all `attached` state handlers.\n *    removeTransitionState('attached')\n *\n * @param {String =} state - Name that matches what's available in the\n * documentation above\n * @param {Function =} callback - Callback to receive the matching elements\n */\nfunction removeTransitionState(state, callback) {\n  if (!callback && state) {\n    _transitions.states[state].length = 0;\n  } else if (state && callback) {\n    // Not a valid state name.\n    if (Object.keys(_transitions.states).indexOf(state) === -1) {\n      throw new Error('Invalid state name ' + state);\n    }\n\n    var index = _transitions.states[state].indexOf(callback);\n    _transitions.states[state].splice(index, 1);\n  } else {\n    for (var _state in _transitions.states) {\n      _transitions.states[_state].length = 0;\n    }\n  }\n}\n\n/**\n * Registers middleware functions which are called during the render\n * transaction flow. These should be very fast and ideally asynchronous to\n * avoid blocking the render.\n *\n * @example\n *\n *    import { use } from 'diffhtml'\n *    import logger from 'diffhtml-logger'\n *\n *    // Add the diffHTML logger middleware, to console out render information.\n *    use(logger)\n *\n *\n * @param {Function} middleware - A function that gets passed internals\n * @return {Function} - When invoked removes and deactivates the middleware\n */\nfunction use(middleware) {\n  if (typeof middleware !== 'function') {\n    throw new Error('Middleware must be a function');\n  }\n\n  // Add the function to the set of middlewares.\n  _cache.MiddlewareCache.add(middleware);\n\n  // The unsubscribe method for the middleware.\n  return function () {\n    // Remove this middleware from the internal cache. This will prevent it\n    // from being invoked in the future.\n    _cache.MiddlewareCache.delete(middleware);\n\n    // Call the unsubscribe method if defined in the middleware (allows them\n    // to cleanup).\n    middleware.unsubscribe && middleware.unsubscribe();\n  };\n}\n\n},{\"./node/release\":5,\"./node/transaction\":6,\"./tree/helpers\":7,\"./util/cache\":10,\"./util/tagged-template\":17,\"./util/transitions\":18}],2:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getFinalizeCallback;\n\nvar _transaction = _dereq_('../node/transaction');\n\nvar _transaction2 = _interopRequireDefault(_transaction);\n\nvar _cache = _dereq_('../util/cache');\n\nvar _memory = _dereq_('../util/memory');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Pulls the next render object (containing the respective arguments to\n * patchNode) and invokes the next transaction.\n *\n * @param state\n */\nvar renderNext = function renderNext(state) {\n  var nextRender = state.nextRender;\n  state.nextRender = undefined;\n\n  (0, _transaction2.default)(nextRender.node, nextRender.newHTML, nextRender.options);\n};\n\n/**\n * Returns a callback that finalizes the transaction, setting the isRendering\n * flag to false. This allows us to pick off and invoke the next available\n * transaction to render. This code recyles the unprotected allocated pool\n * objects and triggers a `renderComplete` event.\n *\n * @param {Object} node - A DOM Node that has just had patches applied\n * @param {Object} state - The current state object associated with the Node\n * @return {Function} - Closure that when called completes the transaction\n */\nfunction getFinalizeCallback(node, state) {\n  /**\n   * When the render completes, clean up memory, and schedule the next render\n   * if necessary.\n   *\n   * @param {Array} remainingMiddleware - Array of middleware to invoke\n   */\n  return function finalizeTransaction() {\n    var remainingMiddleware = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n    var isInner = state.options.inner;\n\n    state.previousMarkup = isInner ? node.innerHTML : node.outerHTML;\n    state.previousText = node.textContent;\n\n    state.isRendering = false;\n\n    // This is designed to handle use cases where renders are being hammered\n    // or when transitions are used with Promises. If this element has a next\n    // render state, trigger it first as priority.\n    if (state.nextRender) {\n      renderNext(state);\n    }\n    // Otherwise dig into the other states and pick off the first one\n    // available.\n    else {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _cache.StateCache.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _state = _step.value;\n\n            if (_state.nextRender) {\n              renderNext(_state);\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n    // Clean out all the existing allocations.\n    (0, _memory.cleanMemory)();\n\n    // Call the remaining middleware signaling the render is complete.\n    for (var i = 0; i < remainingMiddleware.length; i++) {\n      remainingMiddleware[i]();\n    }\n  };\n}\n\n},{\"../node/transaction\":6,\"../util/cache\":10,\"../util/memory\":13}],3:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.default = make;\n\nvar _cache = _dereq_('../util/cache');\n\nvar _svg = _dereq_('../util/svg');\n\nvar svg = _interopRequireWildcard(_svg);\n\nvar _entities = _dereq_('../util/entities');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Gets a specific type of DOM Node depending on the passed in nodeName.\n *\n * @param nodeName {String} - The nodeName to disambiguate the type\n * @param nodeValue {String} - The nodeValue to set if a Text Node\n * @return {Object} - A DOM Node matching the nodeName\n */\nvar createNodeFromName = function createNodeFromName(_ref) {\n  var nodeName = _ref.nodeName;\n  var nodeValue = _ref.nodeValue;\n\n  // If we're dealing with a Text Node, we need to use the special DOM method,\n  // since createElement does not understand the nodeName '#text'.\n  // All other nodes can be created through createElement.\n  if (nodeName === '#text') {\n    return document.createTextNode(nodeValue);\n  }\n  // If the nodeName matches any of the known SVG element names, mark it as\n  // SVG. The reason for doing this over detecting if nested in an <svg>\n  // element, is that we do not currently have circular dependencies in the\n  // VTree, by avoiding parentNode, so there is no way to crawl up the parents.\n  else if (svg.elements.indexOf(nodeName) > -1) {\n      return document.createElementNS(svg.namespace, nodeName);\n    }\n    // If not a Text or SVG Node, then create with the standard method.\n    else {\n        return document.createElement(nodeName);\n      }\n};\n\n/**\n * Takes in a Virtual Tree Element (VTree) and creates a DOM Node from it.\n * Sets the node into the Node cache. If this VTree already has an\n * associated node, it will reuse that.\n *\n * @param {Object} - A Virtual Tree Element or VTree-like element\n * @return {Object} - A DOM Node matching the vTree\n */\nfunction make(vTree) {\n  // If no Virtual Tree Element was specified, return null.\n  if (!vTree) {\n    return null;\n  }\n\n  // If the DOM Node was already created, reuse the existing node.\n  if (_cache.NodeCache.has(vTree)) {\n    return _cache.NodeCache.get(vTree);\n  }\n\n  var node = createNodeFromName(vTree);\n\n  // Copy all the attributes from the vTree into the newly created DOM\n  // Node.\n  for (var i = 0; i < (vTree.attributes || []).length; i++) {\n    var attr = vTree.attributes[i];\n    var isObject = _typeof(attr.value) === 'object';\n    var isFunction = typeof attr.value === 'function';\n\n    // If not a dynamic type, set as an attribute, since it's a valid\n    // attribute value.\n    if (attr.name && !isObject && !isFunction) {\n      node.setAttribute(attr.name, (0, _entities.decodeEntities)(attr.value));\n    } else if (attr.name && typeof attr.value !== 'string') {\n      // Necessary to track the attribute/prop existence.\n      node.setAttribute(attr.name, '');\n\n      // Since this is a dynamic value it gets set as a property.\n      node[attr.name] = attr.value;\n    }\n  }\n\n  // Append all the children into the node, making sure to run them\n  // through this `make` function as well.\n  for (var _i = 0; _i < (vTree.childNodes || []).length; _i++) {\n    node.appendChild(make(vTree.childNodes[_i]));\n  }\n\n  // Add to the nodes cache.\n  _cache.NodeCache.set(vTree, node);\n\n  return node;\n}\n\n},{\"../util/cache\":10,\"../util/entities\":11,\"../util/svg\":16}],4:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.default = patchNode;\n\nvar _make = _dereq_('./make');\n\nvar _make2 = _interopRequireDefault(_make);\n\nvar _transitions = _dereq_('../util/transitions');\n\nvar _parser = _dereq_('../util/parser');\n\nvar _cache = _dereq_('../util/cache');\n\nvar _pools = _dereq_('../util/pools');\n\nvar _memory = _dereq_('../util/memory');\n\nvar _entities = _dereq_('../util/entities');\n\nvar _sync = _dereq_('../tree/sync');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isElementNode = function isElementNode(node) {\n  return node.nodeType === 1;\n};\nvar filter = Array.prototype.filter;\n\n/**\n * Looks to see if an element can be replaced. It must have a parentNode to do\n * so. This will trigger an error when the element does not have a parentNode.\n * This typically happens when trying to replace a disconnected DOM Node or the\n * documentElement.\n *\n * @param {String} verb - Verb to replace in the template string\n * @param {Object} oldNode - Old DOM Node to check if able to be replaced\n * @param {Object} patch - Used to clean up vTree references\n */\nvar checkForMissingParent = function checkForMissingParent(verb, oldNode, patch) {\n  if (!oldNode.parentNode) {\n    // Clean up these elements to keep memory consistent.\n    (0, _memory.unprotectElement)(patch.old);\n    (0, _memory.unprotectElement)(patch.new);\n\n    // Throw an error to stop rendering/inform the developer.\n    throw new Error(('\\n      Can\\'t ' + verb + ' without parent, is this the document root?\\n    ').trim());\n  }\n};\n\n// Trigger the attached transition state for this element and all childNodes.\nvar attach = function attach(_ref) {\n  var vTree = _ref.vTree;\n  var fragment = _ref.fragment;\n  var parentNode = _ref.parentNode;\n  var triggerTransition = _ref.triggerTransition;\n  var state = _ref.state;\n\n  // This element has been attached, so it should definitely be marked as\n  // protected.\n  (0, _memory.protectElement)(vTree);\n\n  // Create a DOM Node for this Virtual Tree element.\n  var node = (0, _make2.default)(vTree);\n\n  // If the element added was a DOM text node or SVG text element, trigger\n  // the textChanged transition.\n  if (vTree.nodeName === '#text') {\n    var promises = (0, _transitions.makePromises)('textChanged', [node], null, vTree.nodeValue);\n\n    node.nodeValue = (0, _entities.decodeEntities)(vTree.nodeValue);\n\n    if (parentNode) {\n      var nodeName = parentNode.nodeName.toLowerCase();\n\n      if (_parser.blockText.has(nodeName)) {\n        parentNode.nodeValue = (0, _entities.decodeEntities)(vTree.nodeValue);\n      }\n    }\n\n    triggerTransition('textChanged', promises);\n  }\n\n  vTree.attributes.forEach(function (attr) {\n    triggerTransition('attributeChanged', (0, _transitions.makePromises)('attributeChanged', [node], attr.name, null, attr.value));\n  });\n\n  // Call all `childNodes` attached callbacks as well.\n  vTree.childNodes.forEach(function (vTree) {\n    return attach({\n      vTree: vTree, parentNode: node, triggerTransition: triggerTransition, state: state\n    });\n  });\n\n  // If a Document Fragment was specified, append the DOM Node into it.\n  if (fragment) {\n    fragment.appendChild(node);\n  }\n\n  return node;\n};\n\n/**\n * Processes a set of patches onto a tracked DOM Node.\n *\n * @param {Object} node - DOM Node to process patchs on\n * @param {Array} patches - Contains patch objects\n */\nfunction patchNode(node, patches) {\n  var state = _cache.StateCache.get(node);\n  var promises = [];\n  var triggerTransition = (0, _transitions.buildTrigger)(promises);\n\n  // Loop through all the patches and apply them.\n\n  var _loop = function _loop(i) {\n    var patch = patches[i];\n    var el = (0, _make2.default)(patch.element);\n    var oldEl = (0, _make2.default)(patch.old);\n    var newEl = (0, _make2.default)(patch.new);\n\n    // Empty the Node's contents. This is an optimization, since `innerHTML`\n    // will be faster than iterating over every element and manually removing.\n    if (patch.__do__ === _sync.REMOVE_ELEMENT_CHILDREN) {\n      var childNodes = filter.call(el.childNodes, isElementNode);\n      var detachPromises = (0, _transitions.makePromises)('detached', childNodes);\n\n      triggerTransition('detached', detachPromises, function (promises) {\n        var callback = function callback() {\n          (0, _memory.unprotectElement)(patch.toRemove);\n          el.innerHTML = '';\n        };\n\n        if (promises && promises.length) {\n          Promise.all(promises).then(callback);\n        } else {\n          callback();\n        }\n      });\n    }\n\n    // Remove the entire Node. Only does something if the Node has a parent\n    // element.\n    else if (patch.__do__ === _sync.REMOVE_ENTIRE_ELEMENT) {\n        var _childNodes = [el].filter(isElementNode);\n        var _detachPromises = (0, _transitions.makePromises)('detached', _childNodes);\n\n        if (el.parentNode) {\n          triggerTransition('detached', _detachPromises, function (promises) {\n            var callback = function callback() {\n              el.parentNode.removeChild(el);\n              (0, _memory.unprotectElement)(patch.toRemove);\n            };\n\n            if (promises && promises.length) {\n              Promise.all(promises).then(callback);\n            } else {\n              callback();\n            }\n          });\n        } else {\n          (0, _memory.unprotectElement)(patch.toRemove);\n        }\n      }\n\n      // Replace the entire Node.\n      else if (patch.__do__ === _sync.REPLACE_ENTIRE_ELEMENT) {\n          (function () {\n            var allPromises = [];\n\n            var attachedPromises = (0, _transitions.makePromises)('attached', [newEl].filter(isElementNode));\n\n            var detachedPromises = (0, _transitions.makePromises)('detached', [oldEl].filter(isElementNode));\n\n            var replacedPromises = (0, _transitions.makePromises)('replaced', [oldEl], newEl);\n\n            // Add all the transition state promises into the main array, we'll use\n            // them all to decide when to alter the DOM.\n            triggerTransition('detached', detachedPromises, function (promises) {\n              allPromises.push.apply(allPromises, promises);\n            });\n\n            triggerTransition('attached', attachedPromises, function (promises) {\n              allPromises.push.apply(allPromises, promises);\n              attach({ vTree: patch.new, triggerTransition: triggerTransition, state: state });\n            });\n\n            triggerTransition('replaced', replacedPromises, function (promises) {\n              allPromises.push.apply(allPromises, promises);\n            });\n\n            (0, _memory.unprotectElement)(patch.old);\n\n            // Reset the tree cache. TODO Look into this...\n            _cache.StateCache.set(newEl, {\n              oldTree: patch.new,\n              element: newEl\n            });\n\n            // Once all the promises have completed, invoke the action, if no\n            // promises were added, this will be a synchronous operation.\n            if (allPromises.length) {\n              Promise.all(allPromises).then(function replaceEntireElement() {\n                checkForMissingParent(oldEl, patch);\n                oldEl.parentNode.replaceChild(newEl, oldEl);\n              }, function (ex) {\n                return console.log(ex);\n              });\n            } else {\n              if (!oldEl.parentNode) {\n                (0, _memory.unprotectElement)(patch.new);\n\n                if (_cache.StateCache.has(newEl)) {\n                  _cache.StateCache.delete(newEl);\n                }\n\n                throw new Error(replaceFailMsg);\n              }\n\n              oldEl.parentNode.replaceChild(newEl, oldEl);\n            }\n          })();\n        }\n\n        // Node manip.\n        else if (patch.__do__ === _sync.MODIFY_ELEMENT) {\n            // Add.\n            if (el && patch.fragment && !oldEl) {\n              (function () {\n                var fragment = document.createDocumentFragment();\n\n                // Loop over every element to be added and process the Virtual Tree\n                // element into the DOM Node and append into the DOM fragment.\n                var toAttach = patch.fragment.map(function (vTree) {\n                  return attach({\n                    vTree: vTree, fragment: fragment, triggerTransition: triggerTransition, state: state\n                  });\n                }).filter(isElementNode);\n\n                // Turn elements into childNodes of the patch element.\n                el.appendChild(fragment);\n\n                // Trigger transitions.\n                var makeAttached = (0, _transitions.makePromises)('attached', toAttach);\n                triggerTransition('attached', makeAttached);\n              })();\n            }\n\n            // Remove.\n            else if (oldEl && !newEl) {\n                // Ensure we can remove the old DOM Node.\n                checkForMissingParent('remove', oldEl, patch);\n\n                var makeDetached = (0, _transitions.makePromises)('detached', [oldEl]);\n\n                triggerTransition('detached', makeDetached, function (promises) {\n                  var callback = function callback() {\n                    if (oldEl.parentNode) {\n                      oldEl.parentNode.removeChild(oldEl);\n                    }\n\n                    // And then empty out the entire contents.\n                    oldEl.innerHTML = '';\n\n                    (0, _memory.unprotectElement)(patch.old);\n                  };\n\n                  if (promises && promises.length) {\n                    Promise.all(promises).then(callback);\n                  } else {\n                    callback();\n                  }\n                });\n              }\n\n              // Replace.\n              else if (oldEl && newEl) {\n                  (function () {\n                    // Ensure we can replace the old DOM Node.\n                    checkForMissingParent('replace', oldEl, patch);\n\n                    // Append the element first, before doing the replacement.\n                    if (oldEl.nextSibling) {\n                      oldEl.parentNode.insertBefore(newEl, oldEl.nextSibling);\n                    } else {\n                      oldEl.parentNode.appendChild(newEl);\n                    }\n\n                    // Removed state for transitions API.\n                    var allPromises = [];\n\n                    var attachPromises = (0, _transitions.makePromises)('attached', [newEl].filter(isElementNode));\n\n                    var detachPromises = (0, _transitions.makePromises)('detached', [oldEl].filter(isElementNode));\n\n                    var replacePromises = (0, _transitions.makePromises)('replaced', [oldEl], newEl);\n\n                    triggerTransition('replaced', replacePromises, function (promises) {\n                      if (promises && promises.length) {\n                        allPromises.push.apply(allPromises, promises);\n                      }\n                    });\n\n                    triggerTransition('detached', detachPromises, function (promises) {\n                      if (promises && promises.length) {\n                        allPromises.push.apply(allPromises, promises);\n                      }\n                    });\n\n                    triggerTransition('attached', attachPromises, function (promises) {\n                      if (promises && promises.filter(Boolean).length) {\n                        allPromises.push.apply(allPromises, promises);\n                      }\n\n                      attach({ vTree: patch.new, triggerTransition: triggerTransition, state: state });\n                    });\n\n                    // Once all the promises have completed, invoke the action, if no\n                    // promises were added, this will be a synchronous operation.\n                    if (allPromises.length) {\n                      Promise.all(allPromises).then(function replaceElement() {\n                        if (oldEl.parentNode) {\n                          oldEl.parentNode.replaceChild(newEl, oldEl);\n                        }\n\n                        (0, _memory.unprotectElement)(patch.old);\n\n                        (0, _memory.protectElement)(patch.new);\n                      }, function (ex) {\n                        return console.log(ex);\n                      });\n                    } else {\n                      checkForMissingParent('replace', oldEl, patch);\n\n                      oldEl.parentNode.replaceChild(newEl, oldEl);\n                      (0, _memory.unprotectElement)(patch.old);\n                      (0, _memory.protectElement)(patch.new);\n                    }\n                  })();\n                }\n          }\n\n          // Attribute manipulation.\n          else if (patch.__do__ === _sync.MODIFY_ATTRIBUTE) {\n              var attributes = patch.attributes;\n\n              attributes.forEach(function (_ref2) {\n                var oldAttr = _ref2.oldAttr;\n                var newAttr = _ref2.newAttr;\n\n                var name = newAttr ? newAttr.name : oldAttr.name;\n                var value = (oldAttr ? oldAttr.value : undefined) || null;\n\n                var attrChangePromises = (0, _transitions.makePromises)('attributeChanged', [el], name, value, newAttr ? newAttr.value : null);\n\n                triggerTransition('attributeChanged', attrChangePromises, function (promises) {\n                  var callback = function callback() {\n                    // Always remove the old attribute, we never re-use it.\n                    if (oldAttr) {\n                      _pools.pools.attributeObject.unprotect(oldAttr);\n\n                      // Remove the Virtual Tree Attribute from the element and memory.\n                      if (!newAttr) {\n                        el.removeAttribute(oldAttr.name);\n\n                        if (oldAttr.name in el) {\n                          el[oldAttr.name] = undefined;\n                        }\n                      }\n                    }\n\n                    // Add/Change the attribute or property.\n                    if (newAttr) {\n                      var isObject = _typeof(newAttr.value) === 'object';\n                      var isFunction = typeof newAttr.value === 'function';\n\n                      // Protect the Virtual Attribute object.\n                      _pools.pools.attributeObject.protect(newAttr);\n\n                      // If not a dynamic type, set as an attribute, since it's a valid\n                      // attribute value.\n                      if (!isObject && !isFunction) {\n                        if (newAttr.name) {\n                          el.setAttribute(newAttr.name, (0, _entities.decodeEntities)(newAttr.value));\n                        }\n                      } else if (typeof newAttr.value !== 'string') {\n                        // Necessary to track the attribute/prop existence.\n                        el.setAttribute(newAttr.name, '');\n\n                        // Since this is a dynamic value it gets set as a property.\n                        el[newAttr.name] = newAttr.value;\n                      }\n\n                      // Support live updating of the value attribute.\n                      if (newAttr.name === 'value' || newAttr.name === 'checked') {\n                        el[newAttr.name] = newAttr.value;\n                      }\n                    }\n                  };\n\n                  if (promises && promises.length) {\n                    Promise.all(promises).then(callback, function unhandledException() {});\n                  } else {\n                    callback();\n                  }\n                });\n              });\n            }\n\n            // Text node manipulation.\n            else if (patch.__do__ === _sync.CHANGE_TEXT) {\n                var textChangePromises = (0, _transitions.makePromises)('textChanged', [el], el.nodeValue, patch.value);\n\n                triggerTransition('textChanged', textChangePromises, function (promises) {\n                  var callback = function callback() {\n                    patch.element.nodeValue = (0, _entities.decodeEntities)(patch.value);\n                    el.nodeValue = patch.element.nodeValue;\n\n                    if (el.parentNode) {\n                      var nodeName = el.parentNode.nodeName.toLowerCase();\n\n                      if (_parser.blockText.has(nodeName)) {\n                        el.parentNode.nodeValue = (0, _entities.decodeEntities)(patch.element.nodeValue);\n                      }\n                    }\n                  };\n\n                  if (promises && promises.length) {\n                    Promise.all(promises).then(callback);\n                  } else {\n                    callback();\n                  }\n                });\n              }\n  };\n\n  for (var i = 0; i < patches.length; i++) {\n    _loop(i);\n  }\n\n  // Return the Promises that were allocated so that rendering can be blocked\n  // until they resolve.\n  return promises.filter(Boolean);\n}\n\n},{\"../tree/sync\":9,\"../util/cache\":10,\"../util/entities\":11,\"../util/memory\":13,\"../util/parser\":14,\"../util/pools\":15,\"../util/transitions\":18,\"./make\":3}],5:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = releaseNode;\n\nvar _cache = _dereq_('../util/cache');\n\nvar _memory = _dereq_('../util/memory');\n\n/**\n * Releases state and recycles internal memory.\n *\n * @param node {Object} - A DOM Node to lookup state from\n */\nfunction releaseNode(node) {\n  // Try and find a state object for this DOM Node.\n  var state = _cache.StateCache.get(node);\n\n  // If there is a Virtual Tree element, recycle all objects allocated for it.\n  if (state && state.oldTree) {\n    (0, _memory.unprotectElement)(state.oldTree);\n  }\n\n  // Remove the Node's state object from the cache.\n  _cache.StateCache.delete(node);\n\n  // Recycle all unprotected objects.\n  (0, _memory.cleanMemory)();\n}\n\n},{\"../util/cache\":10,\"../util/memory\":13}],6:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.default = createTransaction;\n\nvar _patch = _dereq_('./patch');\n\nvar _patch2 = _interopRequireDefault(_patch);\n\nvar _finalize = _dereq_('./finalize');\n\nvar _finalize2 = _interopRequireDefault(_finalize);\n\nvar _make = _dereq_('../tree/make');\n\nvar _make2 = _interopRequireDefault(_make);\n\nvar _sync = _dereq_('../tree/sync');\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _helpers = _dereq_('../tree/helpers');\n\nvar _memory = _dereq_('../util/memory');\n\nvar _parser = _dereq_('../util/parser');\n\nvar _pools = _dereq_('../util/pools');\n\nvar _cache = _dereq_('../util/cache');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * If diffHTML is rendering anywhere asynchronously, we need to wait until it\n * completes before this render can be executed. This sets up the next buffer,\n * if necessary, which serves as a Boolean determination later to `bufferSet`.\n *\n * @param {Object} state - The current DOM Node state within diffHTML\n * @param {Object} nextRender - The respective arguments to set buffer\n * @return {Boolean} - Whether or not diffHTML is currently rendering\n */\nvar setBufferState = function setBufferState(state, nextRender) {\n  // Look up all existing states for any rendering, and set the next render\n  // buffer if blocked.\n  _cache.StateCache.forEach(function (_state) {\n    // If we attach a nextRender, then the buffer has been set.\n    if (_state.isRendering) {\n      state.nextRender = nextRender;\n    }\n  });\n\n  // Let outside code know if we were blocked.\n  return Boolean(state.nextRender);\n};\n\n/**\n * Gets a Virtual Tree Element from the newHTML passed to a diff method.\n *\n * @param {String|Object} newHTML - HTML/DOM Node/Virtual Tree Element\n * @return {Object} - Virtual Tree Element\n */\nvar getTreeFromNewHTML = function getTreeFromNewHTML(newHTML, options, callback) {\n  // This is HTML Markup, so we need to parse it.\n  if (typeof newHTML === 'string') {\n    var silenceWarnings = options.silenceWarnings;\n    var childNodes = (0, _parser.parse)(newHTML, null, { silenceWarnings: silenceWarnings }).childNodes;\n\n    // If we are dealing with innerHTML, use all the Nodes. If we're dealing\n    // with outerHTML, we can only support diffing against a single element,\n    // so pick the first one.\n    return callback(childNodes);\n  }\n  // This is a DOM Node, so we need to convert to a vTree.\n  else if (newHTML.ownerDocument) {\n      var newTree = (0, _make2.default)(newHTML);\n\n      if (newTree.nodeType === 11) {\n        _pools.pools.elementObject.unprotect(newTree);\n        return callback(newTree.childNodes);\n      }\n\n      return callback(newTree);\n    }\n\n  // This is a Virtual Tree Element, or something like it, so we can just pass\n  // it along.\n  return callback(newHTML);\n};\n\n/**\n * Creates a sequential render transaction on a DOM Node. This requires\n * checking for a previous render first. Since diffHTML is globally connected\n * (hopefully only running one copy...), this will prevent transitions from\n * interferring.\n *\n * @param node\n * @param newHTML\n * @param options\n */\nfunction createTransaction(node, newHTML, options) {\n  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {\n    throw new Error('Missing DOM Node object');\n  }\n\n  // Used to associate state with the currently rendering node. This\n  // prevents attaching properties to the instance itself.\n  var state = _cache.StateCache.get(node) || {};\n  var isInner = options.inner;\n  var previousMarkup = state.previousMarkup;\n  var previousText = state.previousText;\n  var bufferSet = setBufferState(state, { node: node, newHTML: newHTML, options: options });\n\n  // Associate the current render options with the DOM Node state.\n  state.options = options;\n\n  // Always ensure the most up-to-date state object is stored.\n  _cache.StateCache.set(node, state);\n\n  // Short circuit the rest of this render if we ended up having to set a\n  // buffer. This happens when some other code using diffHTML is rendering\n  // asynchronously (using transitions w/ Promise).\n  if (bufferSet) {\n    return;\n  }\n\n  // This looks for changes in the DOM from what we'd expect. This means we\n  // need to rebuild the old Virtual Tree. This allows for keeping our tree in\n  // sync with unexpected DOM changes. It's not very performant, so ideally you\n  // should never change markup that diffHTML affects from outside of diffHTML\n  // if performance is a concern.\n  var sameInnerHTML = isInner ? previousMarkup === node.innerHTML : true;\n  var sameOuterHTML = !isInner ? previousMarkup === node.outerHTML : true;\n  var sameTextContent = previousText === node.textContent;\n\n  // If the contents haven't changed, abort, since there is no point in\n  // continuing. Only support this if the new markup is a string, otherwise\n  // it's possible for our object recycling to match twice.\n  if (typeof newHTML === 'string' && state.newHTML === newHTML) {\n    return;\n  }\n  // Associate the last markup rendered with this node.\n  else if (typeof newHTML === 'string') {\n      state.newHTML = newHTML;\n    }\n\n  // We rebuild the tree whenever the DOM Node changes, including the first\n  // time we patch a DOM Node.\n  var rebuildTree = function rebuildTree() {\n    var oldTree = state.oldTree;\n\n    if (oldTree) {\n      (0, _memory.unprotectElement)(oldTree);\n    }\n\n    state.oldTree = (0, _memory.protectElement)((0, _make2.default)(node));\n  };\n\n  if (!sameInnerHTML || !sameOuterHTML || !sameTextContent) {\n    rebuildTree();\n  }\n\n  // We're rendering in the UI thread.\n  state.isRendering = true;\n\n  // Store all transaction starting middleware functions being executed here.\n  var startTransactionMiddlewares = [];\n\n  // Start off the middleware execution.\n  _cache.MiddlewareCache.forEach(function (executeMiddleware) {\n    // Pass the start transaction call with the input arguments.\n    var result = executeMiddleware({ node: node, newHTML: newHTML, options: options });\n\n    if (result) {\n      startTransactionMiddlewares.push(result);\n    }\n  });\n\n  // Alias the `oldTree` off of state for parity.\n  var oldTree = state.oldTree;\n\n  // We need to ensure that our target to diff is a Virtual Tree Element. This\n  // function takes in whatever `newHTML` is and normalizes to a tree object.\n  // The callback function runs on every normalized Node to wrap childNodes\n  // in the case of setting innerHTML.\n  var newTree = getTreeFromNewHTML(newHTML, options, function (newTree) {\n    if (isInner) {\n      _pools.pools.elementObject.unprotect(newTree);\n\n      var nodeName = state.oldTree.nodeName;\n      var attributes = state.oldTree.attributes;\n\n      return (0, _helpers.createElement)(nodeName, attributes, newTree);\n    }\n\n    return Array.isArray(newTree) ? newTree[0] : newTree;\n  });\n\n  // Trigger any middleware with the DOM Node, old Virtual Tree Element, and\n  // new Virtual Tree Element. This allows the middleware to mutate and inspect\n  // the trees before they get consumed by diffHTML.\n  var prePatchMiddlewares = [];\n\n  // By exposing the internal tree synchronization and DOM Node patch methods,\n  // a middleware could implement sync/patch on a separate thread.\n  var transactionMethods = {\n    syncTree: _sync2.default,\n    patchNode: _patch2.default,\n    protectElement: _memory.protectElement,\n    unprotectElement: _memory.unprotectElement\n  };\n\n  // Save the current transaction tree state and allow the mdidleware to\n  // override the trees.\n  var transactionState = {\n    oldTree: oldTree,\n    newTree: newTree,\n    transactionMethods: transactionMethods\n  };\n\n  // Run each middleware and pass the transaction state which contains internal\n  // functions otherwise not available by the public API.\n  for (var i = 0; i < startTransactionMiddlewares.length; i++) {\n    // Pass the the existing Virtual Tree Element, and the new Virtual Tree\n    // Element. This is triggered before the synchronization and patching has\n    // occured.\n    var result = startTransactionMiddlewares[i](transactionState);\n\n    if (result) {\n      prePatchMiddlewares.push(result);\n    }\n  }\n\n  // Synchronize the trees, use any middleware replacements, if supplied.\n  var patches = (0, _sync2.default)(transactionState.oldTree, transactionState.newTree);\n\n  // Apply the set of patches to the Node.\n  var promises = (0, _patch2.default)(node, patches);\n\n  // Trigger any middleware after syncing and patching the element. This is\n  // mainly useful to get the Promises for something like devtools and patches\n  // for something like logging.\n  var postPatchMiddlewares = [];\n\n  for (var _i = 0; _i < prePatchMiddlewares.length; _i++) {\n    // The DOM Node patching has finished and now we're sending the patchset\n    // and the promises which can also be pushed into to do some asynchronous\n    // behavior in a middleware.\n    var _result = prePatchMiddlewares[_i]({\n      patches: patches,\n      promises: promises\n    });\n\n    if (_result) {\n      postPatchMiddlewares.push(_result);\n    }\n  }\n\n  // Clean up and finalize this transaction. If there is another transaction,\n  // get a callback to run once this completes to run it.\n  var finalizeTransaction = (0, _finalize2.default)(node, state);\n\n  // Operate synchronously unless opted into a Promise-chain. Doesn't matter if\n  // they are actually Promises or not, since they will all resolve eventually\n  // with `Promise.all`.\n  if (promises.length) {\n    Promise.all(promises).then(function () {\n      finalizeTransaction(postPatchMiddlewares);\n    }, function (ex) {\n      return console.log(ex);\n    });\n  } else {\n    // Pass off the remaining middleware to allow users to dive into the\n    // transaction completed lifecycle event.\n    finalizeTransaction(postPatchMiddlewares);\n  }\n}\n\n},{\"../tree/helpers\":7,\"../tree/make\":8,\"../tree/sync\":9,\"../util/cache\":10,\"../util/memory\":13,\"../util/parser\":14,\"../util/pools\":15,\"./finalize\":2,\"./patch\":4}],7:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.createElement = createElement;\nexports.createAttribute = createAttribute;\n\nvar _pools = _dereq_('../util/pools');\n\nvar _escape = _dereq_('../util/escape');\n\nvar _escape2 = _interopRequireDefault(_escape);\n\nvar _make = _dereq_('../tree/make');\n\nvar _make2 = _interopRequireDefault(_make);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * TODO Phase this out if possible, super slow iterations...\n *\n * @param childNodes\n * @return\n */\nvar normalizeChildNodes = function normalizeChildNodes(_childNodes) {\n  var newChildNodes = [];\n  var childNodes = Array.isArray(_childNodes) ? _childNodes : [_childNodes];\n\n  childNodes.forEach(function (childNode) {\n    if ((typeof childNode === 'undefined' ? 'undefined' : _typeof(childNode)) !== 'object') {\n      newChildNodes.push(createElement('#text', null, String(childNode)));\n    } else if ('length' in childNode) {\n      for (var i = 0; i < childNode.length; i++) {\n        var newChild = childNode[i];\n        var newNode = newChild.ownerDocument ? (0, _make2.default)(newChild) : newChild;\n\n        newChildNodes.push(newNode);\n      }\n    } else {\n      var node = childNode.ownerDocument ? (0, _make2.default)(childNode) : childNode;\n      newChildNodes.push(node);\n    }\n  });\n\n  return newChildNodes;\n};\n\n/**\n * Creates a virtual element used in or as a virtual tree.\n *\n * @param nodeName\n * @param attributes\n * @param childNodes\n * @return {Object} element\n */\nfunction createElement(nodeName, attributes, childNodes) {\n  if (nodeName === '') {\n    return normalizeChildNodes(childNodes);\n  }\n\n  if (typeof nodeName === 'function') {\n    var props = attributes;\n    props.children = childNodes;\n    return new nodeName(props).render(props);\n  } else if ((typeof nodeName === 'undefined' ? 'undefined' : _typeof(nodeName)) === 'object') {\n    var _props = attributes;\n    _props.children = childNodes;\n    return nodeName.render(_props);\n  }\n\n  var entry = _pools.pools.elementObject.get();\n  var isTextNode = nodeName === 'text' || nodeName === '#text';\n\n  entry.key = '';\n  entry.nodeName = nodeName.toLowerCase();\n  entry.rawNodeName = nodeName;\n\n  if (!isTextNode) {\n    entry.nodeType = 1;\n    entry.nodeValue = '';\n    entry.attributes = attributes || [];\n    entry.childNodes = normalizeChildNodes(childNodes);\n\n    // Set the key prop if passed as an attr.\n    entry.attributes.some(function (attr) {\n      if (attr.name === 'key') {\n        entry.key = attr.value;\n        return true;\n      }\n    });\n  } else {\n    var value = Array.isArray(childNodes) ? childNodes.join('') : childNodes;\n\n    entry.nodeType = nodeName === '#document-fragment' ? 11 : 3;\n    entry.nodeValue = (0, _escape2.default)(String(value));\n    entry.attributes.length = 0;\n    entry.childNodes.length = 0;\n  }\n\n  return entry;\n}\n\n/**\n * Creates a virtual attribute used in a virtual element.\n *\n * @param name\n * @param value\n * @return {Object} attribute\n */\nfunction createAttribute(name, value) {\n  var entry = _pools.pools.attributeObject.get();\n\n  entry.name = name;\n  entry.value = value;\n\n  return entry;\n}\n\n},{\"../tree/make\":8,\"../util/escape\":12,\"../util/pools\":15}],8:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = makeNode;\n\nvar _helpers = _dereq_('./helpers');\n\nvar _pools = _dereq_('../util/pools');\n\nvar _cache = _dereq_('../util/cache');\n\n/**\n * Converts a DOM Node into a Virtual Tree Element.\n *\n * @param {Object} node - A DOM Node\n * @return {Object} - A Virtual Tree Element\n */\nfunction makeNode(node) {\n  // These are the only DOM Node properties we care about.\n  var nodeName = node.nodeName.toLowerCase();\n  var nodeType = node.nodeType;\n  var nodeValue = node.nodeValue;\n  var attributes = node.attributes || [];\n  var childNodes = node.childNodes || [];\n\n  // We ignore any DOM Node that isn't an: Element, Text, Document Fragment, or\n  // Shadow Root.\n  if (nodeType !== 1 && nodeType !== 3 && nodeType !== 11) {\n    return false;\n  }\n\n  // We can consider either of these DOM Nodes as Text Nodes.\n  var isTextNode = nodeName === '#text' || nodeName === 'text';\n\n  // In the case of Text Node's we can have the createElement function set\n  // the nodeValue for us.\n  var initialValue = isTextNode ? nodeValue : [];\n\n  // Creates a Virtual Tree Element based off this nodeName. We aren't going\n  // to set the attributes right away since we want to set the key on the vTree\n  // and push directly into the pre-existing array.\n  var vTree = (0, _helpers.createElement)(node.nodeName, [], initialValue);\n\n  // Creates Virtual Tree Attributes for each attribute in the DOM Node.\n  for (var i = 0; i < attributes.length; i++) {\n    var attr = (0, _helpers.createAttribute)(attributes[i].name, attributes[i].value);\n\n    // If the `key` attribute is found, set the respective value on the vTree.\n    if (attr.name === 'key') {\n      vTree.key = attr.value;\n    }\n\n    vTree.attributes.push(attr);\n  }\n\n  // Associate this newly allocated vTree with this DOM Node.\n  _cache.NodeCache.set(vTree, node);\n\n  // If the element has child nodes, convert them all to virtual nodes.\n  for (var _i = 0; _i < childNodes.length; _i++) {\n    var newNode = makeNode(childNodes[_i]);\n\n    // We may get a falsy value back if we pass in a Comment Node or other\n    // DOM Nodes that we intentionally ignore.\n    if (newNode) {\n      vTree.childNodes.push(newNode);\n    }\n  }\n\n  // Prune out whitespace/everything from between tags nested under the HTML\n  // tag, since this behavior can be observed in browsers and specification.\n  if (vTree.nodeName === 'html') {\n    vTree.childNodes = vTree.childNodes.filter(function (childNode) {\n      return childNode.nodeName === 'head' || childNode.nodeName === 'body';\n    });\n  }\n\n  return vTree;\n}\n\n},{\"../util/cache\":10,\"../util/pools\":15,\"./helpers\":7}],9:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sync;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar slice = Array.prototype.slice;\nvar filter = Array.prototype.filter;\n\n// Patch actions.\nvar REMOVE_ELEMENT_CHILDREN = exports.REMOVE_ELEMENT_CHILDREN = -2;\nvar REMOVE_ENTIRE_ELEMENT = exports.REMOVE_ENTIRE_ELEMENT = -1;\nvar REPLACE_ENTIRE_ELEMENT = exports.REPLACE_ENTIRE_ELEMENT = 0;\nvar MODIFY_ELEMENT = exports.MODIFY_ELEMENT = 1;\nvar MODIFY_ATTRIBUTE = exports.MODIFY_ATTRIBUTE = 2;\nvar CHANGE_TEXT = exports.CHANGE_TEXT = 3;\n\n/**\n * Synchronizes changes from the newTree into the oldTree.\n *\n * @param oldTree\n * @param newTree\n * @param patches - optional\n */\nfunction sync(oldTree, newTree, patches) {\n  patches = patches || [];\n\n  if (!Array.isArray(patches)) {\n    throw new Error('Missing Array to sync patches into');\n  }\n\n  if (!oldTree) {\n    throw new Error('Missing existing tree to sync');\n  }\n\n  var oldNodeValue = oldTree.nodeValue;\n  var oldChildNodes = oldTree.childNodes;\n  var oldIsTextNode = oldTree.nodeName === '#text';\n\n  // TODO Make this static...\n  var oldChildNodesLength = oldChildNodes ? oldChildNodes.length : 0;\n\n  if (!newTree) {\n    var removed = [oldTree].concat(oldChildNodes.splice(0, oldChildNodesLength));\n\n    patches.push({\n      __do__: REMOVE_ENTIRE_ELEMENT,\n      element: oldTree,\n      toRemove: removed\n    });\n\n    return patches;\n  }\n\n  var nodeValue = newTree.nodeValue;\n  var childNodes = newTree.childNodes;\n  var childNodesLength = childNodes ? childNodes.length : 0;\n  var nodeName = newTree.nodeName;\n  var attributes = newTree.attributes;\n  var newIsTextNode = nodeName === '#text';\n  var newIsFragment = newTree.nodeName === '#document-fragment';\n\n  // Replace the key attributes.\n  oldTree.key = newTree.key;\n\n  // If the element we're replacing is totally different from the previous\n  // replace the entire element, don't bother investigating children.\n  if (oldTree.nodeName !== newTree.nodeName) {\n    patches.push({\n      __do__: REPLACE_ENTIRE_ELEMENT,\n      old: oldTree,\n      new: newTree\n    });\n\n    return patches;\n  }\n  // This element never changes.\n  else if (oldTree === newTree) {\n      return patches;\n    }\n\n  var areTextNodes = oldIsTextNode && newIsTextNode;\n\n  // If the top level nodeValue has changed we should reflect it.\n  if (areTextNodes && oldNodeValue !== nodeValue) {\n    patches.push({\n      __do__: CHANGE_TEXT,\n      element: oldTree,\n      value: newTree.nodeValue\n    });\n\n    oldTree.nodeValue = newTree.nodeValue;\n\n    return patches;\n  }\n\n  // Ensure keys exist for all the old & new elements.\n  var noOldKeys = !oldChildNodes.some(function (oldChildNode) {\n    return oldChildNode.key;\n  });\n  var newKeys = null;\n  var oldKeys = null;\n\n  if (!noOldKeys) {\n    newKeys = new Set(childNodes.map(function (childNode) {\n      return String(childNode.key);\n    }).filter(Boolean));\n\n    oldKeys = new Set(oldChildNodes.map(function (childNode) {\n      return String(childNode.key);\n    }).filter(Boolean));\n  }\n\n  // Most common additive elements.\n  if (childNodesLength > oldChildNodesLength) {\n    // Store elements in a DocumentFragment to increase performance and be\n    // generally simplier to work with.\n    var fragment = [];\n\n    for (var i = oldChildNodesLength; i < childNodesLength; i++) {\n      // Internally add to the tree.\n      oldChildNodes.push(childNodes[i]);\n\n      // Add to the document fragment.\n      fragment.push(childNodes[i]);\n    }\n\n    oldChildNodesLength = oldChildNodes.length;\n\n    // Assign the fragment to the patches to be injected.\n    patches.push({\n      __do__: MODIFY_ELEMENT,\n      element: oldTree,\n      fragment: fragment\n    });\n  }\n\n  // Remove these elements.\n  if (oldChildNodesLength > childNodesLength) {\n    (function () {\n      // For now just splice out the end items.\n      var diff = oldChildNodesLength - childNodesLength;\n      var toRemove = [];\n      var shallowClone = [].concat(_toConsumableArray(oldChildNodes));\n\n      // There needs to be keys to diff, if not, there's no point in checking.\n      if (noOldKeys) {\n        toRemove = oldChildNodes.splice(oldChildNodesLength - diff, diff);\n      }\n      // This is an expensive operation so we do the above check to ensure that a\n      // key was specified.\n      else {\n          (function () {\n            var keysToRemove = new Set();\n\n            // Find the keys in the sets to remove.\n            oldKeys.forEach(function (key) {\n              if (!newKeys.has(key)) {\n                keysToRemove.add(key);\n              }\n            });\n\n            // If the original childNodes contain a key attribute, use this to\n            // compare over the naive method below.\n            shallowClone.forEach(function (oldChildNode, i) {\n              if (toRemove.length >= diff) {\n                return;\n              } else if (keysToRemove.has(oldChildNode.key)) {\n                var nextChild = oldChildNodes[i + 1];\n                var nextIsTextNode = nextChild && nextChild.nodeType === 3;\n                var count = 1;\n\n                // Always remove whitespace in between the elements.\n                if (nextIsTextNode && toRemove.length + 2 <= diff) {\n                  count = 2;\n                }\n                // All siblings must contain a key attribute if they exist.\n                else if (nextChild && nextChild.nodeType === 1 && !nextChild.key) {\n                    throw new Error('\\n              All element siblings must consistently contain key attributes.\\n            '.trim());\n                  }\n\n                // Find the index position from the original array.\n                var indexPos = oldChildNodes.indexOf(oldChildNode);\n\n                // Find all the items to remove.\n                toRemove.push.apply(toRemove, oldChildNodes.splice(indexPos, count));\n              }\n            });\n          })();\n        }\n\n      // Ensure we don't remove too many elements by accident;\n      toRemove.length = diff;\n\n      // Ensure our internal length check is matched.\n      oldChildNodesLength = oldChildNodes.length;\n\n      if (childNodesLength === 0) {\n        patches.push({\n          __do__: REMOVE_ELEMENT_CHILDREN,\n          element: oldTree,\n          toRemove: toRemove\n        });\n      } else {\n        // Remove the element, this happens before the splice so that we still\n        // have access to the element.\n        toRemove.forEach(function (old) {\n          return patches.push({\n            __do__: MODIFY_ELEMENT,\n            old: old\n          });\n        });\n      }\n    })();\n  }\n\n  // Replace elements if they are different.\n  if (oldChildNodesLength >= childNodesLength) {\n    for (var _i = 0; _i < childNodesLength; _i++) {\n      if (oldChildNodes[_i].nodeName !== childNodes[_i].nodeName) {\n        // Add to the patches.\n        patches.push({\n          __do__: MODIFY_ELEMENT,\n          old: oldChildNodes[_i],\n          new: childNodes[_i]\n        });\n\n        // Replace the internal tree's point of view of this element.\n        oldChildNodes[_i] = childNodes[_i];\n      } else {\n        sync(oldChildNodes[_i], childNodes[_i], patches);\n      }\n    }\n  }\n\n  // Attributes are significantly easier than elements and we ignore checking\n  // them on fragments. The algorithm is the same as elements, check for\n  // additions/removals based off length, and then iterate once to make\n  // adjustments.\n  if (!newIsFragment && attributes) {\n    // Cache the lengths for performance and readability.\n    var oldLength = oldTree.attributes.length;\n    var newLength = attributes.length;\n\n    // Construct a single patch for the entire changeset.\n    var patch = {\n      __do__: MODIFY_ATTRIBUTE,\n      element: oldTree,\n      attributes: []\n    };\n\n    // Find additions.\n    if (newLength > oldLength) {\n      for (var _i2 = oldLength; _i2 < newLength; _i2++) {\n        var oldAttr = oldTree.attributes[_i2];\n        var newAttr = attributes[_i2];\n\n        patch.attributes.push({ oldAttr: oldAttr, newAttr: newAttr });\n        oldTree.attributes.push(newAttr);\n      }\n    }\n\n    // Find removals.\n    if (oldLength > newLength) {\n      for (var _i3 = newLength; _i3 < oldLength; _i3++) {\n        var _oldAttr = oldTree.attributes[_i3];\n        var _newAttr = attributes[_i3];\n\n        patch.attributes.push({ oldAttr: _oldAttr, newAttr: _newAttr });\n      }\n\n      // Reset the internal attributes to be less.\n      oldTree.attributes = oldTree.attributes.slice(0, newLength);\n    }\n\n    // Find changes.\n    for (var _i4 = 0; _i4 < attributes.length; _i4++) {\n      var _oldAttr2 = oldTree.attributes[_i4];\n      var _newAttr2 = attributes[_i4];\n      var oldAttrName = _oldAttr2 ? _oldAttr2.name : undefined;\n      var oldAttrValue = _oldAttr2 ? _oldAttr2.value : undefined;\n      var newAttrName = _newAttr2 ? _newAttr2.name : undefined;\n      var newAttrValue = _newAttr2 ? _newAttr2.value : undefined;\n\n      // Only push in a change if the attribute or value changes.\n      if (oldAttrValue !== newAttrValue) {\n        // Add the attribute items to add and remove.\n        patch.attributes.push({\n          oldAttr: _oldAttr2,\n          newAttr: _newAttr2\n        });\n\n        oldTree.attributes[_i4] = _newAttr2;\n      }\n    }\n\n    // Add the attribute changes patch to the series of patches, unless there\n    // are no attributes to change.\n    if (patch.attributes.length) {\n      patches.push(patch);\n    }\n  }\n\n  return patches;\n}\n\n},{}],10:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Associates DOM Nodes with state objects.\nvar StateCache = exports.StateCache = new Map();\n\n// Associates Virtual Tree Elements with DOM Nodes.\nvar NodeCache = exports.NodeCache = new Map();\n\n// Caches all middleware. You cannot unset a middleware once it has been added.\nvar MiddlewareCache = exports.MiddlewareCache = new Set();\n\n},{}],11:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeEntities = decodeEntities;\n// Support loading diffHTML in non-browser environments.\nvar element = global.document ? document.createElement('div') : null;\n\n/**\n * Decodes HTML strings.\n *\n * @see http://stackoverflow.com/a/5796718\n * @param string\n * @return unescaped HTML\n */\nfunction decodeEntities(string) {\n  // If there are no HTML entities, we can safely pass the string through.\n  if (!element || !string || !string.indexOf || string.indexOf('&') === -1) {\n    return string;\n  }\n\n  element.innerHTML = string;\n  return element.textContent;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],12:[function(_dereq_,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = escape;\n/**\n * Tiny HTML escaping function, useful to prevent things like XSS and\n * unintentionally breaking attributes with quotes.\n *\n * @param {String} unescaped - An HTML value, unescaped\n * @return {String} - An HTML-safe string\n */\nfunction escape(unescaped) {\n  return unescaped.replace(/[\"&'<>`]/g, function (match) {\n    return \"&#\" + match.charCodeAt(0) + \";\";\n  });\n}\n\n},{}],13:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.protectElement = protectElement;\nexports.unprotectElement = unprotectElement;\nexports.cleanMemory = cleanMemory;\n\nvar _pools = _dereq_('../util/pools');\n\nvar _cache = _dereq_('./cache');\n\n/**\n * Ensures that an element is not recycled during a render cycle.\n *\n * @param element\n * @return element\n */\nfunction protectElement(element) {\n  if (Array.isArray(element)) {\n    return element.forEach(protectElement);\n  }\n\n  var elementObject = _pools.pools.elementObject;\n  var attributeObject = _pools.pools.attributeObject;\n\n  elementObject.protect(element);\n\n  element.attributes.forEach(attributeObject.protect, attributeObject);\n  element.childNodes.forEach(protectElement);\n\n  return element;\n}\n\n/**\n * Allows an element to be recycled during a render cycle.\n *\n * @param element\n * @return\n */\nfunction unprotectElement(element) {\n  if (Array.isArray(element)) {\n    return element.forEach(unprotectElement);\n  }\n\n  var elementObject = _pools.pools.elementObject;\n  var attributeObject = _pools.pools.attributeObject;\n\n  elementObject.unprotect(element);\n\n  element.attributes.forEach(attributeObject.unprotect, attributeObject);\n  element.childNodes.forEach(unprotectElement);\n\n  _cache.NodeCache.delete(element);\n\n  return element;\n}\n\n/**\n * Recycles all unprotected allocations.\n */\nfunction cleanMemory() {\n  var elementCache = _pools.pools.elementObject.cache;\n  var attributeCache = _pools.pools.attributeObject.cache;\n\n  // Empty all element allocations.\n  elementCache.allocated.forEach(function (v) {\n    if (elementCache.free.length < _pools.count) {\n      elementCache.free.push(v);\n    }\n  });\n\n  elementCache.allocated.clear();\n\n  // Clean out unused elements.\n  _cache.NodeCache.forEach(function (node, descriptor) {\n    if (!elementCache.protected.has(descriptor)) {\n      _cache.NodeCache.delete(descriptor);\n    }\n  });\n\n  // Empty all attribute allocations.\n  attributeCache.allocated.forEach(function (v) {\n    if (attributeCache.free.length < _pools.count) {\n      attributeCache.free.push(v);\n    }\n  });\n\n  attributeCache.allocated.clear();\n}\n\n},{\"../util/pools\":15,\"./cache\":10}],14:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blockText = undefined;\nexports.parse = parse;\n\nvar _pools = _dereq_('./pools');\n\nvar _make = _dereq_('../tree/make');\n\nvar _make2 = _interopRequireDefault(_make);\n\nvar _helpers = _dereq_('../tree/helpers');\n\nvar _escape = _dereq_('./escape');\n\nvar _escape2 = _interopRequireDefault(_escape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Code based off of:\n// https://github.com/ashi009/node-fast-html-parser\n\nvar TOKEN = '__DIFFHTML__';\n\nvar doctypeEx = /<!.*>/ig;\nvar attrEx = /\\b([_a-z][_a-z0-9\\-]*)\\s*(=\\s*(\"([^\"]+)\"|'([^']+)'|(\\S+)))?/ig;\nvar tagEx = /<!--[^]*?(?=-->)-->|<(\\/?)([a-z\\-][a-z0-9\\-]*)\\s*([^>]*?)(\\/?)>/ig;\nvar spaceEx = /[^ ]/;\n\n// We use this Set in the node/patch module so marking it exported.\nvar blockText = exports.blockText = new Set(['script', 'noscript', 'style', 'code', 'template']);\n\nvar selfClosing = new Set(['meta', 'img', 'link', 'input', 'area', 'br', 'hr']);\n\nvar kElementsClosedByOpening = {\n  li: { li: true },\n  p: { p: true, div: true },\n  td: { td: true, th: true },\n  th: { td: true, th: true }\n};\n\nvar kElementsClosedByClosing = {\n  li: { ul: true, ol: true },\n  a: { div: true },\n  b: { div: true },\n  i: { div: true },\n  p: { div: true },\n  td: { tr: true, table: true },\n  th: { tr: true, table: true }\n};\n\n/**\n * Interpolate dynamic supplemental values from the tagged template into the\n * tree.\n *\n * @param currentParent\n * @param string\n * @param supplemental\n */\nvar interpolateDynamicBits = function interpolateDynamicBits(currentParent, string, supplemental) {\n  if (string && string.indexOf(TOKEN) > -1) {\n    (function () {\n      var toAdd = [];\n\n      // Break up the incoming string into dynamic parts that are then pushed\n      // into a new set of child nodes.\n      string.split(TOKEN).forEach(function (value, index) {\n        if (index === 0) {\n          // We trim here to allow for newlines before and after markup starts.\n          if (value && value.trim()) {\n            toAdd.push(TextNode(value));\n          }\n\n          // The first item does not mean there was dynamic content.\n          return;\n        }\n\n        // If we are in the second iteration, this\n        var dynamicBit = supplemental.children.shift();\n\n        if (typeof dynamicBit === 'string') {\n          toAdd.push(TextNode(dynamicBit));\n        } else if (Array.isArray(dynamicBit)) {\n          toAdd.push.apply(toAdd, dynamicBit);\n        } else if (dynamicBit.ownerDocument) {\n          toAdd.push((0, _make2.default)(dynamicBit));\n        } else {\n          toAdd.push(dynamicBit);\n        }\n\n        // This is a useful Text Node.\n        if (value && value.trim()) {\n          toAdd.push(TextNode(value));\n        }\n      });\n\n      currentParent.childNodes.push.apply(currentParent.childNodes, toAdd);\n    })();\n  } else if (string && string.length && !doctypeEx.exec(string)) {\n    currentParent.childNodes.push(TextNode(string));\n  }\n};\n\n/**\n * TextNode to contain a text element in DOM tree.\n *\n * @param {String} nodeValue - A value to set in the text,, set unescaped\n * @return {Object} - A Virtual Tree element representing the Text Node\n */\nvar TextNode = function TextNode(value) {\n  var vTree = (0, _helpers.createElement)('#text', [], []);\n  vTree.nodeValue = value;\n  return vTree;\n};\n\n/**\n * HTMLElement, which contains a set of children.\n *\n * Note: this is a minimalist implementation, no complete tree structure\n * provided (no parentNode, nextSibling, previousSibling etc).\n *\n * @param {String} nodeName - DOM Node name\n * @param {Object} rawAttrs - DOM Node Attributes\n * @param {Object} supplemental - Interpolated data from a tagged template\n * @return {Object} vTree\n */\nvar HTMLElement = function HTMLElement(nodeName, rawAttrs, supplemental) {\n  var vTree = (0, _helpers.createElement)(nodeName, [], []);\n\n  for (var match; match = attrEx.exec(rawAttrs || '');) {\n    var name = match[1];\n    var value = match[6] || match[5] || match[4] || match[1];\n    var attr = (0, _helpers.createAttribute)(name, value);\n\n    if (attr.value === TOKEN) {\n      attr.value = supplemental.props.shift();\n    }\n\n    // If a key attribute is found attach directly to the vTree.\n    if (attr.name === 'key') {\n      vTree.key = attr.value;\n    }\n\n    // Look for empty attributes.\n    if (match[6] === '\"\"') {\n      attr.value = '';\n    }\n\n    vTree.attributes.push(attr);\n  }\n\n  return vTree;\n};\n\n/**\n * Parses HTML and returns a root element\n *\n * @param {String} html - String of HTML markup to parse into a Virtual Tree\n * @param {Object} supplemental - Dynamic interpolated data values\n * @param {Object} options - Contains options like silencing warnings\n * @return {Object} - Parsed Virtual Tree Element\n */\nfunction parse(html, supplemental) {\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  var root = HTMLElement('#document-fragment');\n  var stack = [root];\n  var currentParent = root;\n  var lastTextPos = -1;\n\n  // If there are no HTML elements, treat the passed in html as a single\n  // text node.\n  if (html.indexOf('<') === -1 && html) {\n    interpolateDynamicBits(currentParent, html, supplemental);\n    return root;\n  }\n\n  // Look through the HTML markup for valid tags.\n  for (var match, text; match = tagEx.exec(html);) {\n    if (lastTextPos > -1) {\n      if (lastTextPos + match[0].length < tagEx.lastIndex) {\n        // if has content\n        text = html.slice(lastTextPos, tagEx.lastIndex - match[0].length);\n\n        interpolateDynamicBits(currentParent, text, supplemental);\n      }\n    }\n\n    var matchOffset = tagEx.lastIndex - match[0].length;\n\n    if (lastTextPos === -1 && matchOffset > 0) {\n      var string = html.slice(0, matchOffset);\n\n      if (string && string.trim() && !doctypeEx.exec(string)) {\n        interpolateDynamicBits(currentParent, string, supplemental);\n      }\n    }\n\n    lastTextPos = tagEx.lastIndex;\n\n    // This is a comment.\n    if (match[0][1] === '!') {\n      continue;\n    }\n\n    if (!match[1]) {\n      // not </ tags\n      var attrs = {};\n\n      if (!match[4] && kElementsClosedByOpening[currentParent.rawNodeName]) {\n        if (kElementsClosedByOpening[currentParent.rawNodeName][match[2]]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n        }\n      }\n\n      currentParent = currentParent.childNodes[currentParent.childNodes.push(HTMLElement(match[2], match[3], supplemental)) - 1];\n\n      stack.push(currentParent);\n\n      if (blockText.has(match[2])) {\n        // A little test to find next </script> or </style> ...\n        var closeMarkup = '</' + match[2] + '>';\n        var index = html.indexOf(closeMarkup, tagEx.lastIndex);\n        var length = match[2].length;\n\n        if (index === -1) {\n          lastTextPos = tagEx.lastIndex = html.length + 1;\n        } else {\n          lastTextPos = index + closeMarkup.length;\n          tagEx.lastIndex = lastTextPos;\n          match[1] = true;\n        }\n\n        var newText = html.slice(match.index + match[0].length, index);\n        interpolateDynamicBits(currentParent, newText.trim(), supplemental);\n      }\n    }\n\n    if (match[1] || match[4] || selfClosing.has(match[2])) {\n      if (match[2] !== currentParent.rawNodeName && options.strict) {\n        var nodeName = currentParent.rawNodeName;\n\n        // Find a subset of the markup passed in to validate.\n        var markup = html.slice(tagEx.lastIndex - match[0].length).split('\\n').slice(0, 3);\n\n        // Position the caret next to the first non-whitespace character.\n        var caret = Array(spaceEx.exec(markup[0]).index).join(' ') + '^';\n\n        // Craft the warning message and inject it into the markup.\n        markup.splice(1, 0, caret + '\\nPossibly invalid markup. Saw ' + match[2] + ', expected ' + nodeName + '...\\n        ');\n\n        // Throw an error message if the markup isn't what we expected.\n        throw new Error('' + markup.join('\\n'));\n      }\n\n      // </ or /> or <br> etc.\n      while (currentParent) {\n        if (currentParent.rawNodeName == match[2]) {\n          stack.pop();\n          currentParent = stack[stack.length - 1];\n\n          break;\n        } else {\n          var tag = kElementsClosedByClosing[currentParent.rawNodeName];\n\n          // Trying to close current tag, and move on\n          if (tag) {\n\n            if (tag[match[2]]) {\n              stack.pop();\n              currentParent = stack[stack.length - 1];\n\n              continue;\n            }\n          }\n\n          // Use aggressive strategy to handle unmatching markups.\n          break;\n        }\n      }\n    }\n  }\n\n  // Find any last remaining text after the parsing completes over tags.\n  var remainingText = html.slice(lastTextPos === -1 ? 0 : lastTextPos).trim();\n\n  // If the text exists and isn't just whitespace, push into a new TextNode.\n  interpolateDynamicBits(currentParent, remainingText, supplemental);\n\n  // This is an entire document, so only allow the HTML children to be\n  // body or head.\n  if (root.childNodes.length && root.childNodes[0].nodeName === 'html') {\n    (function () {\n      // Store elements from before body end and after body end.\n      var head = { before: [], after: [] };\n      var body = { after: [] };\n      var beforeHead = true;\n      var beforeBody = true;\n      var HTML = root.childNodes[0];\n\n      // Iterate the children and store elements in the proper array for\n      // later concat, replace the current childNodes with this new array.\n      HTML.childNodes = HTML.childNodes.filter(function (el) {\n        // If either body or head, allow as a valid element.\n        if (el.nodeName === 'body' || el.nodeName === 'head') {\n          if (el.nodeName === 'head') {\n            beforeHead = false;\n          }\n\n          if (el.nodeName === 'body') {\n            beforeBody = false;\n          }\n\n          return true;\n        }\n        // Not a valid nested HTML tag element, move to respective container.\n        else if (el.nodeType === 1) {\n            if (beforeHead && beforeBody) {\n              head.before.push(el);\n            } else if (!beforeHead && beforeBody) {\n              head.after.push(el);\n            } else if (!beforeBody) {\n              body.after.push(el);\n            }\n          }\n      });\n\n      // Ensure the first element is the HEAD tag.\n      if (!HTML.childNodes[0] || HTML.childNodes[0].nodeName !== 'head') {\n        var headInstance = _pools.pools.elementObject.get();\n        headInstance.nodeName = 'head';\n        headInstance.childNodes.length = 0;\n        headInstance.attributes.length = 0;\n\n        var existing = headInstance.childNodes;\n        existing.unshift.apply(existing, head.before);\n        existing.push.apply(existing, head.after);\n\n        HTML.childNodes.unshift(headInstance);\n      } else {\n        var _existing = HTML.childNodes[0].childNodes;\n        _existing.unshift.apply(_existing, head.before);\n        _existing.push.apply(_existing, head.after);\n      }\n\n      // Ensure the second element is the body tag.\n      if (!HTML.childNodes[1] || HTML.childNodes[1].nodeName !== 'body') {\n        var bodyInstance = _pools.pools.elementObject.get();\n        bodyInstance.nodeName = 'body';\n        bodyInstance.childNodes.length = 0;\n        bodyInstance.attributes.length = 0;\n\n        var _existing2 = bodyInstance.childNodes;\n        _existing2.push.apply(_existing2, body.after);\n\n        HTML.childNodes.push(bodyInstance);\n      } else {\n        var _existing3 = HTML.childNodes[1].childNodes;\n        _existing3.push.apply(_existing3, body.after);\n      }\n    })();\n  }\n\n  return root;\n}\n\n},{\"../tree/helpers\":7,\"../tree/make\":8,\"./escape\":12,\"./pools\":15}],15:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPool = createPool;\nexports.initializePools = initializePools;\nvar pools = exports.pools = {};\nvar count = exports.count = 10000;\n\n/**\n * Creates a pool to query new or reused values from.\n *\n * @param name\n * @param opts\n * @return {Object} pool\n */\nfunction createPool(name, opts) {\n  var size = opts.size;\n  var fill = opts.fill;\n\n  var cache = {\n    free: [],\n    allocated: new Set(),\n    protected: new Set()\n  };\n\n  // Prime the cache with n objects.\n  for (var i = 0; i < size; i++) {\n    cache.free.push(fill());\n  }\n\n  return {\n    cache: cache,\n\n    get: function get() {\n      var value = cache.free.pop() || fill();\n      cache.allocated.add(value);\n      return value;\n    },\n    protect: function protect(value) {\n      cache.allocated.delete(value);\n      cache.protected.add(value);\n    },\n    unprotect: function unprotect(value) {\n      if (cache.protected.has(value)) {\n        cache.protected.delete(value);\n        cache.free.push(value);\n      }\n    }\n  };\n}\n\nfunction initializePools(COUNT) {\n  pools.attributeObject = createPool('attributeObject', {\n    size: COUNT,\n\n    fill: function fill() {\n      return { name: '', value: '' };\n    }\n  });\n\n  pools.elementObject = createPool('elementObject', {\n    size: COUNT,\n\n    fill: function fill() {\n      return {\n        rawNodeName: '',\n        nodeName: '',\n        nodeValue: '',\n        nodeType: 1,\n        key: '',\n        childNodes: [],\n        attributes: []\n      };\n    }\n  });\n}\n\n// Create ${COUNT} items of each type.\ninitializePools(count);\n\n},{}],16:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// List of SVG elements.\nvar elements = exports.elements = ['altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'set', 'stop', 'svg', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use', 'view', 'vkern'];\n\n// Namespace.\nvar namespace = exports.namespace = 'http://www.w3.org/2000/svg';\n\n},{}],17:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.html = html;\n\nvar _parser = _dereq_('./parser');\n\nvar _escape = _dereq_('./escape');\n\nvar _escape2 = _interopRequireDefault(_escape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isPropEx = /(=|'|\")/;\nvar TOKEN = '__DIFFHTML__';\n\n/**\n * Get the next value from the list. If the next value is a string, make sure\n * it is escaped.\n *\n * @param {Array} values - Values extracted from tagged template literal\n * @return {String|*} - Escaped string, otherwise any value passed\n */\nvar nextValue = function nextValue(values) {\n  var value = values.shift();\n  return typeof value === 'string' ? (0, _escape2.default)(value) : value;\n};\n\n/**\n * Parses tagged template contents into a Virtual Tree. These tagged templates\n * separate static strings from values, so we need to do some special token\n * work\n *\n * @param {Array} strings - A list of static strings, split by value\n * @param {Array} ...values - A list of interpolated values\n * @return {Object|Array} - A Virtual Tree Element or array of elements\n */\nfunction html(strings) {\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n\n  // Automatically coerce a string literal to array.\n  if (typeof strings === 'string') {\n    strings = [strings];\n  }\n\n  // Do not attempt to parse empty strings.\n  if (!strings[0].length && !values.length) {\n    return null;\n  }\n\n  // Parse only the text, no dynamic bits.\n  if (strings.length === 1 && !values.length) {\n    var _childNodes = (0, _parser.parse)(strings[0]).childNodes;\n    return _childNodes.length > 1 ? _childNodes : _childNodes[0];\n  }\n\n  // Used to store markup and tokens.\n  var retVal = [];\n\n  // We filter the supplemental values by where they are used. Values are\n  // either props or children.\n  var supplemental = {\n    props: [],\n    children: []\n  };\n\n  // Loop over the static strings, each break correlates to an interpolated\n  // value. Since these values can be dynamic, we cannot pass them to the\n  // diffHTML HTML parser inline. They are passed as an additional argument\n  // called supplemental. The following loop instruments the markup with tokens\n  // that the parser then uses to assemble the correct tree.\n  strings.forEach(function (string) {\n    // Always add the string, we need it to parse the markup later.\n    retVal.push(string);\n\n    if (values.length) {\n      var value = nextValue(values);\n      var lastSegment = string.split(' ').pop();\n      var lastCharacter = lastSegment.trim().slice(-1);\n      var isProp = Boolean(lastCharacter.match(isPropEx));\n\n      if (isProp) {\n        supplemental.props.push(value);\n        retVal.push(TOKEN);\n      } else if (Array.isArray(value) || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n        supplemental.children.push(value);\n        retVal.push(TOKEN);\n      } else {\n        retVal.push(value);\n      }\n    }\n  });\n\n  // Parse the instrumented markup to get the Virtual Tree.\n  var childNodes = (0, _parser.parse)(retVal.join(''), supplemental).childNodes;\n\n  // This makes it easier to work with a single element as a root, instead of\n  // always return an array.\n  return childNodes.length > 1 ? childNodes : childNodes[0];\n}\n\n},{\"./escape\":12,\"./parser\":14}],18:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildTrigger = buildTrigger;\nexports.makePromises = makePromises;\nvar forEach = Array.prototype.forEach;\n\n/**\n * Contains arrays to store transition callbacks.\n *\n * attached\n * --------\n *\n * For when elements come into the DOM. The callback triggers immediately after\n * the element enters the DOM. It is called with the element as the only\n * argument.\n *\n * detached\n * --------\n *\n * For when elements are removed from the DOM. The callback triggers just\n * before the element leaves the DOM. It is called with the element as the only\n * argument.\n *\n * replaced\n * --------\n *\n * For when elements are replaced in the DOM. The callback triggers after the\n * new element enters the DOM, and before the old element leaves. It is called\n * with old and new elements as arguments, in that order.\n *\n * attributeChanged\n * ----------------\n *\n * Triggered when an element's attribute has changed. The callback triggers\n * after the attribute has changed in the DOM. It is called with the element,\n * the attribute name, old value, and current value.\n *\n * textChanged\n * -----------\n *\n * Triggered when an element's `textContent` chnages. The callback triggers\n * after the textContent has changed in the DOM. It is called with the element,\n * the old value, and current value.\n */\nvar states = exports.states = {\n  attached: [],\n  detached: [],\n  replaced: [],\n  attributeChanged: [],\n  textChanged: []\n};\n\n// Define the custom signatures necessary for the loop to fill in the \"magic\"\n// methods that process the transitions consistently.\nvar fnSignatures = {\n  attached: function attached(el) {\n    return function (cb) {\n      return cb(el);\n    };\n  },\n  detached: function detached(el) {\n    return function (cb) {\n      return cb(el);\n    };\n  },\n  replaced: function replaced(oldEl, newEl) {\n    return function (cb) {\n      return cb(oldEl, newEl);\n    };\n  },\n  textChanged: function textChanged(el, oldVal, newVal) {\n    return function (cb) {\n      return cb(el, oldVal, newVal);\n    };\n  },\n  attributeChanged: function attributeChanged(el, name, oldVal, newVal) {\n    return function (cb) {\n      return cb(el, name, oldVal, newVal);\n    };\n  }\n};\n\nvar make = {};\n\n// Dynamically fill in the custom methods instead of manually constructing\n// them.\nObject.keys(states).forEach(function (stateName) {\n  var mapFn = fnSignatures[stateName];\n\n  /**\n   * Make's the transition promises.\n   *\n   * @param elements\n   * @param args\n   * @param promises\n   */\n  make[stateName] = function makeTransitionPromises(elements, args, promises) {\n    // Sometimes an array-like is passed so using forEach in this manner yields\n    // more consistent results.\n    forEach.call(elements, function (element) {\n      // Never pass text nodes to a state callback unless it is textChanged.\n      if (stateName !== 'textChanged' && element.nodeType !== 1) {\n        return;\n      }\n\n      // Call the map function with each element.\n      var newPromises = states[stateName].map(mapFn.apply(null, [element].concat(args)));\n\n      // Merge these Promises into the main cache.\n      promises.push.apply(promises, newPromises);\n\n      // Recursively call into the children if attached or detached.\n      if (stateName === 'attached' || stateName === 'detached') {\n        make[stateName](element.childNodes, args, promises);\n      }\n    });\n\n    return promises.filter(function (promise) {\n      return Boolean(promise && promise.then);\n    });\n  };\n});\n\n/**\n * Builds a reusable trigger mechanism for the element transitions.\n *\n * @param allPromises\n */\nfunction buildTrigger(allPromises) {\n  var addPromises = allPromises.push.apply.bind(allPromises.push, allPromises);\n\n  // This becomes `triggerTransition` in process.js.\n  return function (stateName, makePromisesCallback, callback) {\n    if (states[stateName] && states[stateName].length) {\n      // Calls into each custom hook to bind Promises into the local array,\n      // these will then get merged into the main `allPromises` array.\n      var promises = makePromisesCallback([]);\n\n      // Add these promises into the global cache.\n      addPromises(promises);\n\n      if (callback) {\n        callback(promises.length ? promises : undefined);\n      }\n    } else if (callback) {\n      callback();\n    }\n  };\n}\n\n/**\n * Make a reusable function for easy transition calling.\n *\n * @param stateName\n */\nfunction makePromises(stateName) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  // Ensure elements is always an array.\n  var elements = [].concat(args[0]);\n\n  // Accepts the local Array of promises to use.\n  return function (promises) {\n    return make[stateName](elements, args.slice(1), promises);\n  };\n}\n\n},{}]},{},[1])(1)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/diffhtml/dist/diffhtml.js\n// module id = 1\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","import { ActivityData } from './interfaces/ActivityData';\n\nimport LasagnaActivityLogElement from './elements/LasagnaActivityLogElement';\n\n/**\n * Implement custom elements\n */\n(<any>window).customElements.define('lasagna-activity-log', LasagnaActivityLogElement);\n\n/**\n * Start app\n */\nwindow.addEventListener('load', () => {\n  const today = new Date();\n  const activities: ActivityData[] = [];\n  const activityLog = document.querySelector('lasagna-activity-log');\n  activityLog.setAttribute('date', today.toISOString().substr(0, 10));\n  activityLog.setAttribute('activities', JSON.stringify(activities));\n});\n\n\n// WEBPACK FOOTER //\n// ./src/app.ts"],"sourceRoot":""}